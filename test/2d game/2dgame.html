<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>2dgame</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../../css/styles.css">
</head>

<body>
    <div id="scene-container">
    </div>
    <div id="info">
        <p>2dgame</p>
    </div>
    <div id="blocker">
        <div id="instructions">
            <span style="font-size:36px">Loading...</span>
            </br></br>
            Move: AD</br>
            Jump: Space</br>
        </div>
    </div>

    <script src="../../cannon/build/cannon.min.js"></script>
    <script type="module">

        import * as THREE from '../../three.js/build/three.module.js';

        import Stats from '../../three.js/examples/jsm/libs/stats.module.js';
        // import { GUI } from '../../three.js/examples/jsm/libs/dat.gui.module.js';
        import { OrbitControls } from '../../three.js/examples/jsm/controls/OrbitControls.js';
        import { PointerLockControls } from '../../three.js/examples/jsm/controls/PointerLockControls.js';


        import { SVGLoader } from '../../three.js/examples/jsm/loaders/SVGLoader.js';

        // if( WEBGL.isWebGLAvailable() === false ){

        //     document.body.appendChild( WEBGL.getWebGLErrorMessage() );

        // }

        let container = document.querySelector('#scene-container');

        let container_width = container.offsetWidth;
        let container_height = container.offsetHeight;
        // let containerHalfX = container_width / 2;
        // let containerHalfY = container_height / 2;

        // let stats;
        let controls;
        // let clock = new THREE.Clock();

        let camera, scene, renderer;

        let sphere, sphereBody;
        let groundHalf = new CANNON.Vec3(5.5, 0.05, 5);

        let world;

        //控制2d介面
        let controls2d = new PointerLockControls(camera, document.body);

        let blocker = document.getElementById("blocker");
        let instructions = document.getElementById("instructions");

        //鍵盤控制
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;

        //建立場景
        function init() {

            scene = new THREE.Scene();
            // scene.background = new THREE.Color( 0x444444 );
            // scene.fog = new THREE.Fog( 0xcccccc, 100, 1500 );

            let axes = new THREE.AxesHelper(20)
            scene.add(axes)

            createCamera();
            createLights();
            createMeshes();
            createObject();
            createPhysical();
            createRenderer();
            // createPostprocessing();
            // createControls();
            // createStats();
            createEvent();


            renderer.setAnimationLoop(() => {

                // stats.begin();
                update();
                render();
                // if ( statsEnabled ) 
                // stats.update();
                // stats.end();

            });
        }

        //創建相機
        function createCamera() {

            let fov = 65;
            let aspect = container_width / container_height;
            let near = 0.1;
            let far = 1000;
            camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera.position.z = 30;
            camera.lookAt(scene.position)

            // let left = - containerHalfX;
            // let right = containerHalfX;
            // let top = containerHalfY;
            // let bottom = - containerHalfY;
            // near = 1, far = 10;
            // cameraOrtho = new THREE.OrthographicCamera( left, right, top, bottom, near, far);
            // cameraOrtho.position.z = 10;

        }

        //創建光源
        function createLights() {

            scene.add(new THREE.AmbientLight(0xffffff));

            // let dirLight = new THREE.DirectionalLight( 0xffffff, 0.8 );
            // dirLight.position.set( -3000, 1000, -1000 );  
            // scene.add( dirLight );

            // let hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444 );
            // hemiLight.position.set( 0, 1000, 0 );
            // scene.add( hemiLight );

            // let light = new THREE.PointLight( 0xffffff, 1.0, 50, 2 );
            // light.position.y = 2;
            // group.add( light );

        }

        //實現網格
        function createMeshes() {

            // 地圖網格
            let tilesMat = new THREE.MeshLambertMaterial({
                color: 0xcccccc,
                side: THREE.DoubleSide
            });
            let tilesGeo = new THREE.BoxGeometry(groundHalf.x * 2, groundHalf.y * 2, groundHalf.z * 2, 20, 32);
            let tiles = new THREE.Mesh(tilesGeo, tilesMat);
            tiles.position.set(-17, 0, 0);
            scene.add(tiles);

            // 球網格
            let sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
            let sphereMaterial = new THREE.MeshStandardMaterial({ color: 0x33aaaa });
            sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere.position.set(10, 10, 0);
            scene.add(sphere);

        }

        //載入物件
        function createObject() {

            let loader = new SVGLoader();

            loader.load("./assets/freetileset/svg/Sample.svg", function (data) {
                let paths = data.paths;
                let group = new THREE.Group();
                group.scale.multiplyScalar(0.00043);
                group.position.x = -25;
                group.position.y = 19.5;
                group.scale.y *= - 1;
                for (let i = 0; i < paths.length; i++) {
                    let path = paths[i];
                    let fillColor = path.userData.style.fill;
                    let material = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setStyle(fillColor),
                        opacity: path.userData.style.fillOpacity,
                        transparent: path.userData.style.fillOpacity < 1,
                        side: THREE.DoubleSide,
                        depthWrite: false,
                    });
                    let shapes = path.toShapes(true);
                    for (let j = 0; j < shapes.length; j++) {
                        let shape = shapes[j];
                        let geometry = new THREE.ShapeBufferGeometry(shape);
                        let mesh = new THREE.Mesh(geometry, material);
                        group.add(mesh);
                    }

                }

                scene.add(group);
            }, onProgress, onError);

        }

        //利用cannon.js建立物理效果
        function createPhysical() {

            // 建立物理世界
            world = new CANNON.World();

            // 設定重力場為 y 軸 -9.8 m/s²
            world.gravity.set(0, -9.8, 0);

            // 碰撞偵測
            world.broadphase = new CANNON.NaiveBroadphase();

            // 建立地板剛體
            let groundCM = new CANNON.Material();
            let groundBody = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Box(groundHalf),
                position: new CANNON.Vec3(-17, -13.8, 0),
                material: groundCM
            });

            // let groundBody2 = new CANNON.Body({
            //     mass: 0,
            //     shape: new CANNON.Box(new CANNON.Vec3(5, 0.05, 5)),
            //     position: new CANNON.Vec3(-1, -8, 0),
            //     material: groundCM
            // });
            // setFromAxisAngle 旋轉 x 軸 -90 度
            // groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.add(groundBody);
            // world.add(groundBody2);

            // 建立球剛體
            let sphereShape = new CANNON.Sphere(1);
            let sphereCM = new CANNON.Material();
            sphereBody = new CANNON.Body({
                mass: 10,
                shape: sphereShape,
                position: new CANNON.Vec3(-11, 2, 0),
                material: sphereCM
            })
            world.add(sphereBody);

            // // 設定兩剛體碰撞時交互作用屬性
            // sphereGroundContact = new CANNON.ContactMaterial(groundCM, sphereCM, {
            // friction: friction, // 摩擦力
            // restitution: restitution // 恢復係數, 衡量兩個物體碰撞後反彈程度
            // });
            // world.addContactMaterial(sphereGroundContact);

        }

        //實現渲染
        function createRenderer() {

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(container_width, container_height);
            renderer.setPixelRatio(window.devicePixelRatio);

            // renderer.shadowMap.enabled = true;
            // renderer.shadowMap.type = THREE.BasicShadowMap;

            container.appendChild(renderer.domElement);

        }

        //新增動畫
        function addMorph(mesh, clip, speed, duration, x, y, z, fudgeColor, massOptimization) {

        }

        //創建Postprocessing
        function createPostprocessing() {

            // composer = new EffectComposer(renderer);
            // composer.addPass(new RenderPass(scene, camera));

            // pass = new SMAAPass(window.innerWidth * renderer.getPixelRatio(), window.innerHeight * renderer.getPixelRatio());
            // composer.addPass(pass);

        }

        //實現控制
        function createControls() {

            controls = new OrbitControls(camera, renderer.domElement);
            controls.update();

        }

        //新增執行效率
        function createStats() {

            // if( statsEnabled ){
            // stats = new Stats();
            // container.appendChild(stats.dom);
            // }

        }

        //創建事件
        function createEvent() {

            // window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('keydown', onWindowKeyDown, false);
            window.addEventListener('keyup', onWindowKeyUp, false);

            instructions.addEventListener('click', function () {
                controls2d.lock();
            }, false);

            controls2d.addEventListener('lock', function () {
                instructions.style.display = 'none';
                blocker.style.display = 'none';
            });

            controls2d.addEventListener('unlock', function () {
                blocker.style.backgroundColor = 'rgba(0,0,0,0.5)';
                blocker.style.display = 'block';
                instructions.style.display = '';
            });

        }

        function onWindowKeyDown(event) {

            switch (event.keyCode) {

                case 37:// left
                case 65:// a
                    moveLeft = true;
                    break;

                case 39:// right
                case 68:// d
                    moveRight = true;
                    break;

                case 32:// space
                    // if( canJump === true ) velocity.y += 15;
                    canJump = true;
                    break;
            }
        }

        function onWindowKeyUp(event) {

            switch (event.keyCode) {

                case 37:// left
                case 65:// a
                    moveLeft = false;
                    break;

                case 39:// right
                case 68:// d
                    moveRight = false;
                    break;

                case 32:// space
                    canJump = false;
                    break;

            }
        }

        //載入等待
        function onProgress(xhr) {
            if (xhr.lengthComputable) {
                // updateProgressBar(xhr.loaded / xhr.total);
                console.log(Math.round(xhr.loaded / xhr.total * 100, 2) + '% downloaded');
            }
            if (xhr = 1) {
                instructions.getElementsByTagName('span')[0].innerText = 'Click to Play';
            }
        }

        //載入失敗
        function onError() {
            let message = "Error loading model";
            instructions.innerText = message;
            console.log(message);
        }

        //載入%數
        // function updateProgressBar(fraction) {
        //     instructions.getElementsByTagName('span')[0].innerText = 'Loading...' + Math.round(fraction * 100, 2) + '%';            
        // }

        //Object事件
        function update() {

            if (moveLeft) {
                sphere.position.x -= 0.1;
                sphere.rotation.x -= 0.1;
                console.log(sphere.position);
            };

            if (moveRight) {
                sphere.position.x += 0.1;
                sphere.rotation.x += 0.1;
                console.log(sphere.position);
            };

            if (canJump) {
                sphere.position.y += 0.1;
                console.log(sphere.position);
            };

        }

        //渲染更新
        function render() {

            // if( postprocessing.enabled ){

            const timeStep = 1.0 / 60.0; // seconds

            world.step(timeStep)
            if (sphere) {
                sphere.position.copy(sphereBody.position);
                sphere.quaternion.copy(sphereBody.quaternion);
            };


            renderer.render(scene, camera);

            // }else{



            // }                

        }

        init();

    </script>

</body>

</html>